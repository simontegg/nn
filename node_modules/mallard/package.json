{
  "name": "mallard",
  "version": "1.1.0",
  "description": "Data Classification and Machine Learning algorithms",
  "main": "index.js",
  "scripts": {
    "test": "gulp test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/stevedocious/mallard.git"
  },
  "keywords": [
    "utility"
  ],
  "author": {
    "name": "stevedocious"
  },
  "license": "LGPLv3",
  "bugs": {
    "url": "https://github.com/stevedocious/mallard/issues"
  },
  "homepage": "https://github.com/stevedocious/mallard",
  "devDependencies": {
    "gulp": "^3.8.6",
    "chai": "^1.9.1",
    "sinon": "^1.10.3",
    "conventional-changelog": "0.0.11",
    "gulp-jshint": "^1.8.0",
    "gulp-mocha": "^0.5.2",
    "gulp-istanbul": "^0.2.1",
    "gulp-coveralls": "^0.1.2",
    "jshint-stylish": "^0.4.0",
    "gulp-bump": "^0.1.11",
    "gulp-git": "^0.5.0"
  },
  "dependencies": {
    "pocketwrench": "0.0.1"
  },
  "readme": "mallard\r\n========\r\n\r\nData Classification and Machine Learning algorithms.\r\n\r\n[![NPM version](https://badge.fury.io/js/mallard.svg)](http://badge.fury.io/js/mallard)\r\n[![Build Status](https://travis-ci.org/stevedocious/mallard.svg?branch=master)](https://travis-ci.org/stevedocious/mallard)\r\n[![Coverage Status](https://img.shields.io/coveralls/stevedocious/mallard.svg)](https://coveralls.io/r/stevedocious/mallard?branch=master)\r\n\r\n### Module Overview\r\n\r\nBased on the book [Machine Learning in Action](http://www.manning.com/pharrington/) by Peter Harrington, *mallard* contains a\r\ntranslation of the algorithms from the orignal Python into JavaScript. The algorithms implemented so far are:\r\n\r\n- [kNN](http://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm) -  The k nearest neighbours algorithm classifies an unknown\r\nentity by working out the closest neighbours to it in a known dataset. The known data needs to be numerical so that distances\r\nbetween neighbours can be calculated.\r\n- [ID3](http://en.wikipedia.org/wiki/ID3_algorithm) - The ID3 decision tree algorithm uses known data to produce a decision tree\r\nthat can then be used to classify an unknown entity. The known data for this algorithm needs to be discrete values because\r\nthe generated decision tree checks for exactly matched values.\r\n- [Naive Bayes](http://en.wikipedia.org/wiki/Naive_Bayes_classifier) - The Naive Bayes algorithm uses a training dataset to calculate\r\nthe probabilities of a datapoint occurring in each category. These probabilities are then mapped onto the datapoints in the\r\ninput, and a most probable category computed.\r\n\r\n### Usage\r\n\r\nTo load *mallard*, just require it:\r\n\r\n```javascript\r\nvar mallard = require('mallard');\r\n```\r\n\r\nIn order to correctly classify an entity, the algorithms require a dataset of already known data. This is provided in the\r\nformat of an array of objects, each object having two properties. The first property is *category*, which gives the\r\nclassification of the object. The second property is *datapoints* which is an array of the values of the known features\r\nof that object.\r\n\r\n```javascript\r\nvar dataset = [\r\n  { \"category\" : \"A\", \"datapoints\" : [\"x\", \"y\", \"z\"]},\r\n  { \"category\" : \"B\", \"datapoints\" : [\"s\", \"t\", \"u\"]}\r\n];\r\n```\r\n\r\n#### kNN\r\n\r\nSuppose we have a mystery duck (just go with me on this), and we want to know whether it is a member of the Mallard family or the Muscovy family. Now,\r\nwe know the length, wingspan, weight and type of a bunch of ducks, so we load all the data into a dataset as follows:\r\n\r\n*Note: This data is entirely fictional, so please do not use it in any live duck classification schenarios.*\r\n\r\n```javascript\r\nvar continuousDataset = [\r\n  { \"category\" : \"Mallard\", \"datapoints\" : [55, 87, 0.953952]},\r\n  { \"category\" : \"Mallard\", \"datapoints\" : [51, 81, 0.917523]},\r\n  { \"category\" : \"Muscovy\", \"datapoints\" : [72, 140, 1.126542]},\r\n  { \"category\" : \"Mallard\", \"datapoints\" : [60, 90, 1.351631]},\r\n  { \"category\" : \"Mallard\", \"datapoints\" : [67, 95, 1.512341]},\r\n  { \"category\" : \"Muscovy\", \"datapoints\" : [66, 150, 2.354634]},\r\n  { \"category\" : \"Muscovy\", \"datapoints\" : [81, 145, 4.344334]},\r\n  { \"category\" : \"Muscovy\", \"datapoints\" : [84, 137, 3.123083]},\r\n  { \"category\" : \"Mallard\", \"datapoints\" : [57, 89, 0.812545]},  \r\n  { \"category\" : \"Muscovy\", \"datapoints\" : [65, 150, 2.124541]},\r\n  { \"category\" : \"Mallard\", \"datapoints\" : [61, 90, 1.0065432]},\r\n  { \"category\" : \"Muscovy\", \"datapoints\" : [70, 139, 1.7846383]}\r\n];\r\n```\r\n\r\nNow we measure our mystery duck and find that it is 72cm long, has a wingspan of 105cm and weighs 2.123234kg, so we use the *kNN* function\r\nto find the nearest k matching ducks to these measurements. In this case we set k to 3.\r\n\r\n```javascript\r\nmallard.kNN.kNN([72, 105, 2.123234], continuousDataset, 3)\r\n\r\n==> [ { category: 'Mallard',\r\n        distance: 0.2718076518009722 },\r\n      { category: 'Mallard',\r\n        distance: 0.47667718685043636 },\r\n      { category: 'Muscovy',\r\n        distance: 0.505638657863494 } ]\r\n```\r\n\r\nThe *kNN* function returns the 3 nearest ducks, which are 2 Mallards and 1 Muscovy, so we can take the majority vote and say that our duck is\r\na Mallard. If we just want the classification and don't really want to see the neighbours, we can just use the *classify* function:\r\n\r\n```javascript\r\nmallard.kNN.classify([72, 105, 2.123234], continuousDataset, 3)\r\n\r\n==> \"Mallard\"\r\n```\r\n\r\n#### ID3 Decision Tree\r\n\r\nSuppose we can't catch our mystery duck in order to measure it, but we do at least know what it looks like. If we know what typical Mallard and Muscovy\r\nducks look like we can use an ID3 decision tree to work through the possibilities. We load the data for the decision tree the same way as we load\r\nthe data for the kNN algorithm:\r\n\r\n```javascript\r\nvar discreteDataset = [\r\n  {\"category\" : \"Mallard\", \"datapoints\" : [\"green\", \"male\", \"adult\"]},\r\n  {\"category\" : \"Mallard\", \"datapoints\" : [\"brown\", \"female\", \"adult\"]},\r\n  {\"category\" : \"Mallard\", \"datapoints\" : [\"green\", \"male\", \"child\"]},\r\n  {\"category\" : \"Mallard\", \"datapoints\" : [\"brown\", \"female\", \"child\"]},\r\n  {\"category\" : \"Muscovy\", \"datapoints\" : [\"black\", \"male\", \"adult\"]},\r\n  {\"category\" : \"Muscovy\", \"datapoints\" : [\"black\", \"female\", \"adult\"]},\r\n  {\"category\" : \"Muscovy\", \"datapoints\" : [\"white\", \"male\", \"child\"]},\r\n  {\"category\" : \"Muscovy\", \"datapoints\" : [\"white\", \"female\", \"child\"]}\r\n];\r\n```\r\n\r\nIn addition we also specify what each column represents. This is used in building the tree, and can be used to visually verify the tree is\r\nstructured correctly.\r\n\r\n```javascript\r\nvar featureNames = [\"head colour\", \"sex\", \"age\"];\r\n\r\n```\r\n\r\nBefore we can classify our duck using ID3, we first need to build a decision tree from our sample data using the *createTree* function:\r\n\r\n```javascript\r\nvar tree = mallard.ID3.createTree(discreteDataset, featureNames);\r\n```\r\n\r\nWe can then use that generated tree to examine our mystery duck. If we know our mystery duck is a male child with a white head then we can\r\nuse the *classify* function as follows:\r\n\r\n```javascript\r\nmallard.ID3.classify([\"white\", \"male\", \"child\"], tree, featureNames)\r\n\r\n==> \"Muscovy\"\r\n```\r\n\r\n#### Naive Bayes\r\n\r\nSuppose we have a set of descriptions for our two different types of duck, and then a description of a mystery duck, and we want to\r\nfind out what our mystery duck is. Naive Bayes excels at classifying items based on the probability that certain tokens (words)\r\nare associated with a category.\r\n\r\nTo use Naive Bayes, first we need to train the algorithm using our set of known descriptions. *tokenize* is a\r\nconvenience function which will convert a sentence into a set of tokens to be used as the datapoints in the algorithm.\r\n*train* will take our training dataset and calculate the probabilities that each token appears in each category.\r\n\r\n```javascript\r\nvar ducks = [\r\n  {\"category\" : \"Mallard\", \"datapoints\" : mallard.bayes.tokenize('The male birds have a glossy green head and are grey on wings and belly, while the females have mainly brown-speckled plumage.')},\r\n  {\"category\" : \"Mallard\", \"datapoints\" : mallard.bayes.tokenize('The male has a dark green head, a yellow bill, is mainly purple-brown on the breast and grey on the body.')},\r\n  {\"category\" : \"Mallard\", \"datapoints\" : mallard.bayes.tokenize('The female is mainly brown with an orange bill')},\r\n  {\"category\" : \"Mallard\", \"datapoints\" : mallard.bayes.tokenize('The males sport a glossy green head and white neck ring, and what the females lack in colour they make up for in noise.')},\r\n  {\"category\" : \"Mallard\", \"datapoints\" : mallard.bayes.tokenize('The green head and yellow bill of the mallard duck is a familiar sight to many people living in the Northern hemisphere.')},\r\n  {\"category\" : \"Muscovy\", \"datapoints\" : mallard.bayes.tokenize('The bird is predominantly black and white, with the back feathers being iridescent and glossy in males, while the females are more drab.')},\r\n  {\"category\" : \"Muscovy\", \"datapoints\" : mallard.bayes.tokenize('Wild Muscovy ducks are all black with white patches on the upper and under wing.')},\r\n  {\"category\" : \"Muscovy\", \"datapoints\" : mallard.bayes.tokenize('They may be black, blue, chocolate, lavender or white.')},\r\n  {\"category\" : \"Muscovy\", \"datapoints\" : mallard.bayes.tokenize('The original, wild type, coloration is black and white, but domestication has produced many more colors, including white, black, chocolate, and blue')},\r\n];\r\n\r\nvar trainedDataset = mallard.bayes.train(ducks);\r\n```\r\n\r\nAfter training the algorithm, we just need to call the *classify* function with our unknown sentence to get a prediction for\r\nwhat it is.\r\n\r\n```javascript\r\nmallard.bayes.classify('A small duck with a green head', trainedDataset);\r\n\r\n==> { category: 'Mallard', probability: -16.872226918131254 }\r\n```\r\n\r\nSo using Naive Bayes, our mystery duck is predicted to be a mallard, which is correct.\r\n",
  "readmeFilename": "README.md",
  "_id": "mallard@1.1.0",
  "_shasum": "151b0a754491e00f8ff513987687a7a96686d5af",
  "_from": "mallard@",
  "_resolved": "https://registry.npmjs.org/mallard/-/mallard-1.1.0.tgz"
}
